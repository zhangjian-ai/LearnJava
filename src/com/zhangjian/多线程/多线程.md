## 相关概念

- **进程：** 进程就是运行中的程序。
    - 需要占用计算机物理资源，程序启动时，由操作系统调度分配。
    - 是计算机中最小的资源分配单位。即想要分配计算机的物理资源，至少得是一个完整的进程。
    - 进程创建时都有一个唯一标识PID。
    - 进程之间可以共用CPU资源；但内存资源是严格区分并隔离，互不干扰。父子进程间亦是如此。
    - 父进程负责开启和回收子进程的资源。
- **线程：**是操作系统能够进行运算调度的最小单位。
    - 它被包含在进程之中，是进程中的实际运作单位。可以理解进程是CPU为程序分配了一间办公室，而线程才是办公室中真正干活的，所以线程之间是共享进程资源的。
    - 计算机具体执行编译后的计算机指令就是在线程中进行。
    - 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。一个进程中至少有一个线程。
- **并发：**
    - 在单一的CPU上，同时运行多个计算机程序。
    - 宏观上：多个程序是同时运行的。
    - 微观上：多个程序在CPU上按时间片的时间轮流执行，本质上是串行。
- **并行：**
    - 多个CPU同时运行多个程序，互不干扰。
- **单线程**
    - 同一时刻，只允许运行一个线程。在 Python 中，因为GIL锁的存在，即使计算机有多个CPU，在某一时刻，Python程序也只会使用其中一个，运行一个线程。除非手动开启多进程。
- **多进程**
    - 同一时刻，可以同时运行一个进程的多个线程。Java 就支持多线程，即进程在运行时，可以将多个线程调度到不同的CPU上同时运行。



## 基本使用

> java中获取CPU核心数：
>
> ```java
> package com.zhangjian.多线程;
> 
> public class MultiThread {
>     public static void main(String[] args) {
> 
>         Runtime runtime = Runtime.getRuntime();
>         int i = runtime.availableProcessors(); // 当前计算机上面的可用核心数
> 
>         System.out.println(i);
>     }
> }
> ```



在java中，开启线程主要有两种方式。一是 继承 Thread 类；二是 实现 Runnable 接口。



### 继承 Thread  

继承 Thread 类之后，子类要实现 run 方法，这个方法里面主要是自己的业务逻辑。然后通过实例调用 start 方法，程序救护开启新的线程来执行 run方法。

```java
package com.zhangjian.多线程;

public class MultiThread {
    public static void main(String[] args) throws InterruptedException {
        // 先打印下主线程的信息
        System.out.println(Thread.currentThread().getName());

        // 开启子线程运行程序，主线线程不会阻塞
        Son son = new Son();
        son.start();

        // son.join(); // join() 方法，表示等待子线程结束后才继续执行主线程。一旦调用就会阻塞主线程

        System.out.println("主线程执行完毕");
    }
}


class Son extends Thread {
    @Override
    public void run() {
        // 打印当前线程信息
        // 因为 继承了 Thread ，所以当前了可以直接查看 线程信息
        System.out.println(getName());

        int count = 0;
        while (true){
            System.out.println("计数器 --> " + count);
            count++;

            if (count == 5) break;

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}
```



### 实现 Runnable

java 实现继承机制，在很多情况下，由于当前类已经继承其他父类，就没办法再继承Thread。这种情况下，就可以通过 实现 Runnable 接口 来实现业务逻辑，在使用 Thread 实例开启线程。步骤如下：

1. 实现 Runnable 接口，实现 run 方法逻辑
2. 创建 子类实例，用子类实例作为 Thread 实例的入参
3. 调用 Thread 实例 start 方法 开启线程



代码：

```java
package com.zhangjian.多线程;

public class MultiThread {
    public static void main(String[] args) throws InterruptedException {
        // 先打印下主线程的信息
        System.out.println(Thread.currentThread().getName());

        // 开启子线程运行程序
        Son son = new Son();

        // Runnable 中 只有一个 run 方法，是没办法开启线程执行的
        // 此时 还需要使用 Thread 类，我们需要将实现了 Runnable 接口的类的对象作为构造器参数传入
        Thread thread = new Thread(son);

        // 开启线程。其他使用方法 就和 继承 Thread 没有差异了
        thread.start();

        // thread.join(); // join() 方法，表示等待子线程结束后才继续执行主线程。一旦调用就会阻塞主线程

        System.out.println("主线程执行完毕");
    }
}


class Son implements Runnable {
    @Override
    public void run() {
        // 打印当前线程信息
        // 实现 接口就没法直接使用Thread方法了呢
        System.out.println(Thread.currentThread().getName());

        int count = 0;
        while (true){
            System.out.println("计数器 --> " + count);
            count++;

            if (count == 5) break;

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}
```



### 差异分析

上面两种开启现成的方式，本质上是一样的。继承 Thread 实例化时 相当于调用无参构造器，实现 Runnable 的处理方案则是一个有参构造器。

1. 查看两个构造器，可以看到 这两个构造器内部，调用的同一个 重载的 另一个构造器

    ```java
    // 无参
    public Thread() {
      this(null, null, "Thread-" + nextThreadNum(), 0);
    }
    
    // Runnable 参数
    public Thread(Runnable target) {
      this(null, target, "Thread-" + nextThreadNum(), 0);
    }
    ```

2. 继续追踪，发现 传入的实例 被 Thread 的 target 属性维护起来了

    ```java
        private Thread(ThreadGroup g, Runnable target, String name,
                       long stackSize, AccessControlContext acc,
                       boolean inheritThreadLocals) {
    				
            ... 
              
            this.target = target;  // 无参时，这里 target 为null；带参时 target 就是 Runnable 实例
            setPriority(priority);
            if (inheritThreadLocals && parent.inheritableThreadLocals != null)
                this.inheritableThreadLocals =
                    ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
            /* Stash the specified stack size in case the VM cares */
            this.stackSize = stackSize;
    
            /* Set thread ID */
            this.tid = nextThreadID();
        }
    ```

3. 再看我们最终被调度的 run 方法，可以得到结论。

    ```java
    @Override
    public void run() {
      if (target != null) {
        target.run();
      }
    }
    
    /*
    结论：
     	1、当我们继承 Thread 时，直接就重写了 run 方法，所以被调度时，就是我们自己的逻辑；
     	2、通过实现 Runnable 则没有重写 Thread 的 run，而是实现类的实例给到了 target，当 Thread 的run方法被调用时，通过 target 调用到了 Runnable 的 run 方法。标准的 曲线救国
    */
    ```

    



## 常用方法

从前面知道，创建线程都依赖于 Thread 实例，这里介绍一些 Thread 中的常用方法。

1. setName  设置线程名称
2. getName  获取线程名称
3. start  启动一个新的线程，底层创建新线程后，执行 run 方法
4. run  通常不直接调用，其内部实现是业务逻辑
5. setPriority  设置线程的优先级。默认 优先级是 0，该值是被 CPU 调度的优先级
6. getPriority  获取线程的优先级
7. sleep  静态方法。接收一个 毫秒 参数，让当前线程休眠指定 毫秒数
8. interrupt   中断线程，调用该方法 会在 线程 内部抛出一个 中断异常（InterruptedException）
9. currentThread  静态方法。获取当前的线程对象
10. yield  静态方法。提示调度器当前线程愿意让出正在使用的处理器，但是调度器是可以忽略这个提示的。当有很多CPU任务在执行的时候，调用yield是比较有效的。
11. join  等待线程终止，调用该方法后，阻塞主线程。join 重载了三次。
    - 无参。表示一直等待线程执行，直到线程真正执行完毕
    - 一个参数（毫秒）。等待超时时间为 指定的 毫秒数，超时后主线程终止阻塞，继续执行
    - 两个参数（毫秒, 纳秒）。超时时间为 指定的 毫秒数 + 纳秒属，超时后主线程终止阻塞，继续执行
12. setDaemon  指定线程为 守护线程。守护线程 会在所有其他线程退出后才退出。
13. isDaemon  返回布尔值，线程是否为守护线程
14. isAlive  返回布尔值，线程是否还存活



演示：

```java
package com.zhangjian.多线程;

public class MultiThread {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new Son());
        thread.setName("王老五");

        // 启动线程
        thread.start();

        // 打印线程名称
        System.out.println(thread.getName()); // "王老五"

        // 子线程 sleep 5s ，我们在 主线程 sleep 3s 后，给一个中断信号
        for (int i = 0; i < 3;) {
            Thread.sleep(1000);
            System.out.println("计时：" + (++i));
        }
        thread.interrupt();

        // 子线程再次 sleep 5s ，我们 使用 join 等待8s
        thread.join(8000);

        //  检查线程是否还存活
        System.out.println(thread.isAlive());  // true

        // 通过设置属性，终止线程
        Son.loop = false;

        System.out.println("主线程执行完毕");
    }
}


class Son implements Runnable {
    public static boolean loop = true;

    @Override
    public void run() {
        while (loop){
            System.out.println("累了，睡 5 秒钟...");

            try {
                // 在 sleep 中收到 中断信号，程序就会 抛出 InterruptedException
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                System.out.println("我去，被强行开机了...");
                // e.printStackTrace();
            }
        }

    }
}
```



## 守护线程

1. 用户线程：也叫工作线程。当线程的任务执行完成 或者 被通知 的方式结束
2. 守护线程：一般是为 工作线程 服务的，比如：检查工作线程状态。守护线程 在所有的 工作线程 退出后 自动退出（即使 守护线程 是无限循环的，仍然会自动退出）
3. 常见的守护线程：垃圾回收



## 线程状态

线程状态本质上和进程状态类似的，当进程内部只有一个线程时，二者的状态可以说是一样的。

进程的状态：新建态、就绪态、运行态、阻塞态、终止态

在 Java 中，官方将线程状态氛围以下几种：

- [`NEW`]
    尚未启动的线程处于此状态。
- [`RUNNABLE`]
    在Java虚拟机中执行的线程处于此状态。
- [`BLOCKED`]
    被阻塞等待监视器锁定的线程处于此状态。
- [`WAITING`]
    正在等待另一个线程执行特定动作的线程处于此状态。
- [`TIMED_WAITING`]
    正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。
- [`TERMINATED`]
    已退出的线程处于此状态。



可以看到：

- RUNNABLE 其实 表示了 就绪态 和 运行态，线程是否在运行取决于操作系统是否为其分配处理器，但前提是 线程处于 就绪态
- 另外。Java 中又将 阻塞态 细分成了三种状态，其实等待某个任务执行完成，本身也是阻塞。



下面看一张状态关系图：

<img src="./images/ThreadState.png">





## 线程同步

### 概念

> **线程同步：** 当有一个线程在对某一个内存进行操作时，其他线程都不可以对这个内存进行操作，直到当前线程操作结束之后，其他线程才可以继续去操作。这样可以保证线程间的数据安全

Java语言中，为了实现线程同步，引入了互斥锁的概念，来保证 共享数据 的完整性。同时 使用 `synchronized` 关键字 来与互斥锁联系，当某个对象被 `synchronized`  修饰时，就表示该对象在同一时刻，只能被一个线程访问。`synchronized` 关键字可以实现 同步代码块 和 同步方法，详细语法如下：

1. 同步代码块。默认锁对象是 当前实例(this)，当然也可以是其他实例

    ```java
    // 对象 是指当前的锁，是属于哪个对象的。
    // 1、线程运行时，从对象中获取锁，拿到锁的线程才能执行代码块
    // 2、没有拿到锁的线程，将等待。直到锁被上一个持有的线程释放后，再去争抢  
    synchronized (对象) {
      // 被同步的代码...
    }
    
    // 示例：放在非静态的代码块中
    class Son implements Runnable {
        private int ticketNum = 100;
        public static boolean loop = true;
    
        {
            synchronized (this){
                ticketNum++;
            }
        }
    }
    ```

2. 静态同步代码块。默认锁对象是 当前类.class

    ```java
    synchronized (类名.class) {
      // 被同步的代码...
    }
    
    // 示例：放在静态代码块中
    static {
      synchronized (Son.class){
        int num = 0;
      }
    }
    ```

3. 同步方法。默认锁对象是 当前实例(this)

    ```java
    访问修饰符 synchronized 返回类型 方法名(参数列表){
      // 被同步的代码...
    }
    
    // 示例：
    class Son implements Runnable {
        private int ticketNum = 100;
        public static boolean loop = true;
        
        
        private synchronized void sell(){
            String name = Thread.currentThread().getName();
    
            if (ticketNum >= 0) {
                System.out.println("售票员 " + name + " 卖出一张，余票还有： " + (--ticketNum));
            }
    
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        @Override
        public  void run() {
            while (loop) {
                sell();
                if (ticketNum <= 0) break;
            }
        }
    }
    ```

4. 静态同步方法。默认锁对象是 当前类.class

    ```java
    访问修饰符 static synchronized 返回类型 方法名(参数列表){
      // 被同步的代码...
    }
    
    // 示例：
    class Son implements Runnable {
        private static int ticketNum = 100;
        public static boolean loop = true;
        
        private static synchronized void sell(){
            String name = Thread.currentThread().getName();
    
            if (ticketNum >= 0) {
                System.out.println("售票员 " + name + " 卖出一张，余票还有： " + (--ticketNum));
            }
    
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    
        @Override
        public  void run() {
            while (loop) {
                sell();
                if (ticketNum <= 0) break;
            }
        }
    }
    ```

    

### 注意事项

1. 开启多线程时，传递给线程的对象必须是相同对象
2. 互斥锁能保证多个线程在访问同一个对象时，共享数据的安全性。但同时也牺牲了执行效率，同步 本质上就是让访问串行化，这又恰恰与多线程相违背
3. 可能的情况下，优先使用同步代码块，锁的粒度越小，那么牺牲的效率也就越少
4. 同步代码块不能直接定义在成员级别，只能放在 代码块 或 方法中



### 代码演示

使用 同步代码块 对部分代码加互斥锁，保证 售票 的数据安全。

```java
package com.zhangjian.多线程;

public class MultiThread {
    public static void main(String[] args) throws InterruptedException {
        // 开三个窗口买票
        // 但是只能是同一个票源
        Seller seller = new Seller();

        new Thread(seller).start();
        new Thread(seller).start();
        new Thread(seller).start();

        System.out.println("窗口开放完成");
    }
}


class Seller implements Runnable {
    private int ticketNum = 100;
    public static boolean loop = true;

    private void sell() {
        String name = Thread.currentThread().getName();

        // 在这段代码中。查询余票 和 修改剩余票数，在多线程场景下存在数据不安全的问题，因此对这部分加锁
        synchronized (this) {
            if (ticketNum > 0) {
                System.out.println("售票员 " + name + " 卖出一张，余票还有： " + (--ticketNum));
            }
        }

        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void run() {
        while (loop) {
            sell();
            if (ticketNum <= 0) break;
        }
    }
}
```



## 死锁

当多个线程都占用了对方的锁资源，但是又互不相让，都在等待对方释放锁，就会导致 死锁。

死锁 带来的直接影响就是两个线程一直处于等待状态，无法正常工作。

代码演示：

```java
package com.zhangjian.多线程;

public class MultiThread {
    public static void main(String[] args) throws InterruptedException {
        // 模拟死锁
        Thread thread = new Thread(new DeadLock(true));
        Thread thread2 = new Thread(new DeadLock(false));

        thread.start();
        thread2.start();

        thread.join(2000);

        // 查看状态。两个线程都处于阻塞状态
        System.out.println(thread.getState()); // BLOCKED
        System.out.println(thread2.getState()); // BLOCKED

    }
}


class DeadLock implements Runnable {
    static Object o1 = new Object();
    static Object o2 = new Object();

    private boolean flag;

    public DeadLock(boolean flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        if (flag) {
            synchronized (o1) {
                System.out.println(Thread.currentThread().getName() + " 获得 o1 的锁...");
                synchronized (o2) {
                    System.out.println(Thread.currentThread().getName() + " 获得 o2 的锁...");
                }
            }
        } else {
            synchronized (o2) {
                System.out.println(Thread.currentThread().getName() + " 获得 o2 的锁...");
                synchronized (o1) {
                    System.out.println(Thread.currentThread().getName() + " 获得 o1 的锁...");
                }
            }
        }
    }
}
```



## 释放锁

下面的操作会释放锁：

1. 当前线程的同步方法、同步代码块执行结束，会自动释放锁
2. 当前线程的同步方法、同步代码块中遇到 break、return 会释放锁
3. 当前线程的同步方法、同步代码块中出现了未处理的Error或Exception，导致程序异常结束时会释放锁
4. 当前线程的同步方法、同步代码块中执行了线程对象的 wait() 方法，会暂停当前线程而释放锁



**注意** 以下操作不会释放锁：

1. 线程执行同步代码块或同步方法时，程序调用 Thread.sleep() 、 Thread.yield() 方法，暂停当前线程的执行，不会释放锁
2. 线程执行同步代码块或同步方法时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放锁