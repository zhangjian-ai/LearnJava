## 三层架构

- **controller**

    控制层。接收前端发送的请求，对请求进行处理，并响应数据。

- **service**

    业务逻辑层。负责处理具体的业务逻辑实现

- **dao**

    数据访问层（Data Access Object），又叫 持久层，负责数据访问操作，包括对数据的 增、删、改、查。



使用三层架构将业务代码分层处理后，使得代码 复用性更强、更易于维护 且 更方便拓展。

在三层架构中，controller 层依赖 service层；service 层又依赖 dao层。因此在 实现 service 和 dao 层时，通常实现 service 和 dao 的方式会有很多，为了规范各层之间的调用，我们要使用到 **面向接口** 编程的思想。



**代码演示：**

> 将一个文本信息（诗）读取到之后，加上 作者信息 信息后，返回给前端

Dao层接口：

```java
package com.zhangjian.dao;

/**
 * 数据访问层接口
 */
public interface PoemDao {
    String read();
}
```

Dao层实现：

```java
package com.zhangjian.dao.impl;

import com.zhangjian.dao.PoemDao;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Objects;

public class PoemDaoA implements PoemDao {

    @Override
    public String read() {
        InputStream resource = this.getClass().getResourceAsStream("/static/静夜诗.txt");
        BufferedReader reader = new BufferedReader(new InputStreamReader(Objects.requireNonNull(resource)));

        StringBuilder builder = new StringBuilder();
        String line;

        try {
            while ((line = reader.readLine()) != null){
                builder.append(line);
                builder.append("\n");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        return builder.toString();
    }
}
```



Service层接口：

```java
package com.zhangjian.service;

/**
 * 业务实现层接口
 */
public interface PoemService {
    String addRight();
}
```

Service层实现：

```java
package com.zhangjian.service.impl;

import com.zhangjian.dao.PoemDao;
import com.zhangjian.dao.impl.PoemDaoA;
import com.zhangjian.service.PoemService;
import org.springframework.stereotype.Component;

@Component
public class PoemServiceA implements PoemService {

    private PoemDao poemDao = new PoemDaoA();

    @Override
    public String addRight() {
        String content = poemDao.read();

        return content + "\n\t\t\t\t 唐.李白";
    }
}
```



Controller层：

```java
package com.zhangjian.controller;

import com.zhangjian.service.PoemService;
import com.zhangjian.service.impl.PoemServiceA;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class PoemController {

    private PoemService poemService = new PoemServiceA();

    @GetMapping("getPoem")
    public String  getPoem(){
        String content = poemService.addRight();
        return content;
    }
}
```



## 分层解耦

> 内聚：软件中各个功能模块内部的功能联系。
>
> 耦合：衡量软件中各个 层/模块 之间的依赖、关联程度。

**软件设计原则：高内聚、低耦合**

在 三层架构 章节中的示例代码中，controller 中创建了 service 的实例，service 中又创建了 dao的实例。这样一来，几个模块间耦合度极高，一但 dao 或 service 中的增加了实现类，依赖的一方也必然要修改代码。这严重的违背了 软件设计原则。

为了解决这一问题，引入 容器 的概念，我们将 对象的创建 交给容器，同时 容器 为应用程序提供运行时所依赖的资源，这里有几个重要的概念：

- **控制反转**

    Inversion Of Control，简称 IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为 控制反转。

- **依赖注入**

    Dependency Injection，简称 DI。容器为应用程序提供运行时所依赖的资源，称之为 依赖注入。

- **Bean对象**

    IOC容器中，创建并管理的对象，称之为 bean。



**代码演示：**

> 使用 IOC&DI 的方式，改造 三层架构中的代码。分为三步：
>
> 1. Service层 和 Dao层的实现类，交给 IOC容器管理。方式：使用 @Component 注解标记实现类
> 2. 为 Controller 和 Service 注入运行时依赖的对象。方式：使用 @Autowired 注解标记申明资源的属性
> 3. 运行测试

Dao层实现：

```java
package com.zhangjian.dao.impl;

import com.zhangjian.dao.PoemDao;
import org.springframework.stereotype.Component;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Objects;

@Component
public class PoemDaoA implements PoemDao {

    @Override
    public String read() {
        InputStream resource = this.getClass().getResourceAsStream("/static/静夜诗.txt");
        BufferedReader reader = new BufferedReader(new InputStreamReader(Objects.requireNonNull(resource)));

        StringBuilder builder = new StringBuilder();
        String line;

        try {
            while ((line = reader.readLine()) != null){
                builder.append(line);
                builder.append("\n");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        return builder.toString();
    }
}
```

Service层实现：

```java
package com.zhangjian.service.impl;

import com.zhangjian.dao.PoemDao;
import com.zhangjian.dao.impl.PoemDaoA;
import com.zhangjian.service.PoemService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class PoemServiceA implements PoemService {

    @Autowired
    private PoemDao poemDao;

    @Override
    public String addRight() {
        String content = poemDao.read();

        return content + "\n\t\t\t\t 唐.李白";
    }
}
```

Controller层实现：

```java
package com.zhangjian.controller;

import com.zhangjian.service.PoemService;
import com.zhangjian.service.impl.PoemServiceA;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class PoemController {

    @Autowired
    private PoemService poemService;

    @GetMapping("getPoem")
    public String getPoem() {
        String content = poemService.addRight();
        return content;
    }
}
```



## IOC 详解

**Bean的申明**

要把某个对象交给IOC容器管理，需要在对应的类上加上如下的注解之一。

<table border='1'>
  <tr style="text-align:center">
    <th>注解</th>
    <th>说明</th>
    <th>位置</th>
  </tr>
  <tr>
    <td>@Component</td>
    <td>声明bean的基础注解</td>
    <td>不属于以下三类时，用此注解。比如一些工具类</td>
  </tr>
  <tr>
    <td>@Controller</td>
    <td>@Component的衍生注解</td>
    <td>标注在控制器类上</td>
  </tr>
  <tr>
    <td>@Service</td>
    <td>@Component的衍生注解</td>
    <td>标注在业务类上</td>
  </tr>
  <tr>
    <td>@Repository</td>
    <td>@Component的衍生注解</td>
    <td>标注在数据访问类上（由于与mybatis整合，用得少）</td>
  </tr>
</table>

​	

**注意事项：**

1. 声明bean的时候，可以通过value属性指定bean的名字。如果没有指定，默认为 类名的首字母小写。
2. 使用以上4个注解都可以申明bean，但是在springboot继承web开发中，声明控制器bean只能用 @Controller。
3. 前面声明bean的四大注解，想要生效，还需要被组件扫描注解 @ComponentScan 扫描到。
4. @ComponentScan 扫描注解虽然没有显式配置，但实际上已经包含在了启动类声明注解 @SpringBootApplication 中，默认扫描范围是 启动类所在包及其子包。



## DI 详解

@Autowired 注解，默认是按照 **类型** 为目标程序注入bean。但如果在 IOC 容器中存在多个类型相同的bean，那么程序将报错。

针对这种情况，有如下三种处理方式：

1. @Primary 注解。在需要注入的某个实现类上，再标注上这个注解，告诉虚拟机，资源注入时，使用这个实现类型。

    ```java
    package com.zhangjian.dao.impl;
    
    import com.zhangjian.dao.PoemDao;
    import org.springframework.context.annotation.Primary;
    import org.springframework.stereotype.Repository;
    
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStream;
    import java.io.InputStreamReader;
    import java.util.Objects;
    
    @Primary
    @Repository
    public class PoemDaoB implements PoemDao {
    
        @Override
        public String read() {
            InputStream resource = this.getClass().getClassLoader().getResourceAsStream("static/清平调其一.txt");
            BufferedReader reader = new BufferedReader(new InputStreamReader(Objects.requireNonNull(resource)));
    
            StringBuilder builder = new StringBuilder();
            String line;
    
            try {
                while ((line = reader.readLine()) != null){
                    builder.append(line);
                    builder.append("\n");
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
    
            return builder.toString();
        }
    }
    ```

2. @Qualifier 注解。在需要注入的程序上，使用这个注解，来指定注入哪个实现类的bean。

    ```java
    package com.zhangjian.service.impl;
    
    import com.zhangjian.dao.PoemDao;
    import com.zhangjian.dao.impl.PoemDaoA;
    import com.zhangjian.service.PoemService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.beans.factory.annotation.Qualifier;
    import org.springframework.stereotype.Component;
    import org.springframework.stereotype.Service;
    
    @Service
    public class PoemServiceA implements PoemService {
    
        @Qualifier("poemDaoB")
        @Autowired
        private PoemDao poemDao;
    
        @Override
        public String addRight() {
            String content = poemDao.read();
    
            return content + "\n\t\t\t\t 唐.李白";
        }
    }
    ```

3. @Resource 注解。使用该注解替代 @Autowired注解，@Resource 可以指定注入哪个实现类的bean。

    ```java
    package com.zhangjian.service.impl;
    
    import com.zhangjian.dao.PoemDao;
    import com.zhangjian.dao.impl.PoemDaoA;
    import com.zhangjian.service.PoemService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.beans.factory.annotation.Qualifier;
    import org.springframework.stereotype.Component;
    import org.springframework.stereotype.Service;
    
    import javax.annotation.Resource;
    
    @Service
    public class PoemServiceA implements PoemService {
    
        @Resource(name = "poemDaoA")
        private PoemDao poemDao;
    
        @Override
        public String addRight() {
            String content = poemDao.read();
    
            return content + "\n\t\t\t\t 唐.李白";
        }
    }
    ```



**@Resource 和 @Autowired 的区别：**

1. @Autowired 是Spring提供的注解；@Resource 是JDK提供的注解
2. @Autowired 注解按照 bean的类型注入；@Resource 注解按照给定的 bean的名称注入



## 常见术语

1. **PO（Persistent Object）- 持久化对象**

    PO是由ORM（对象关系映射）框架生成或手动创建的Java对象，它们通常具有与数据库中的表相同的字段和数据类型。在Java开发中，PO常常被用作DAO（数据访问对象）层的数据模型，以及和数据库交互的对象。PO对象中的字段与数据库中的列相对应，每一行数据对应一个PO对象，PO对象中的字段值就是对应列的值。

2. **VO（View Object）- 视图对象**

    主要对应界面显示的数据对象。它的作用是把某个指定页面（或组件）的所有数据封装起来。理解为业务层返回给前端页面的数据对象。

3. **BO（Business Object）- 业务对象**

    BO通常用于表示某个业务逻辑的实体或者模型。BO通常包含一些业务逻辑和方法，例如计算某些值、验证数据、调用其他服务等等。在Java开发中，BO对象通常由Service层或者Facade层来创建，并且它们通常包含一些业务逻辑的实现，以及对数据的操作。BO通常是针对具体的业务场景而设计的，它们是具有业务含义的实体。

4. **DTO（Data Transfer Object）- 数据传输对象**

    数据传输对象，主要用于远程调用等需要大量传输对象的地方。比如我们一张表有100个字段，那么对应的PO就有100个属性。但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。在这里，我泛指用于展示层与服务层之间的数据传输对象。

5. **Entity（实体）**

    实体代表持久化对象，与数据库表相对应，包含与业务逻辑相关的数据和方法。用于与数据库交互，执行CRUD操作以及表示业务领域中的核心对象。

6. **DO（Domain Object）- 领域对象**

    领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。它用来接收数据库对应的实体，是一种抽象化的数据状态，介于数据库与业务逻辑之间。一般在业务逻辑层（Service）对数据库（SQL） 进行访问时，用于接收数据。xxxDO，xxx即为数据表名。另外，DO与Entity的不同点就是DO是与数据库存在着某种映射关系的Entity，总的来说DO是Entity的一种。

7. **POJO（Plain Old Java Object）- 简单的Java对象**

    POJO是一种普通的Java对象，它不依赖于任何框架或技术。POJO通常只包含属性和对应的getter和setter方法，用于存储和获取数据。POJO的设计目标是保持代码的简洁和可读性，使得代码更易于理解和维护。

    POJO是最常见最多变的对象，是一个中间对象，也是我们最常打交道的对象。一个POJO持久化以后就是PO，直接用它传递、传递过程中就是DTO，直接用来对应表示层就是VO。（POJO、PO、DTO、VO都是处理流程中的名字，不是PO对应一个POJO，DTO对应一个POJO，VO对应一个POJO，在有些情况下PO、DTO、VO是指同一个POJO）



